# 微服务架构

# 微服务的服务视图

想象一个向消费者提供产品信息的分布式系统。如下图，这个服务由 7 个微服务组成，从 A 到 G。A 服务存储了用户的个人信息。B 服务存储用户的登录账户信息，如用户上一次登录的时间和访问了什么信息。C 服务是关于产品信息的。D 服务作为 API 网关处理所有来自外部的接口访问。

![](https://i.postimg.cc/ZndWQ4nX/image.png)

- 请求首先进入 D 服务，即 API 服务；

- D 服务本身并没有所有需要的信息，所以它进一步请求 C 服务和 F 服务以获取必要的数据；

- C 服务和 F 服务也同时都需要更多的信息来满足请求，于是 C 服务请求 A 服务，F 服务请求了 B 服务和 G 服务；

- A 服务也需要访问 B 服务，B 服务需要访问 E 服务，同时 G 服务也需要访问 E 服务；

- 对 D 服务的一个请求，扩散到了整个微服务架构里。而且当所有依赖的服务没有返回或者超时之前，API 不会向手机 App 返回响应。

在简单的系统中我们能够根据功能来对服务进行划分，而对于大型复杂系统，则会根据 Facade 接口、应用服务、领域服务和基础服务等层划分，然后各层服务协同配合，为外部提供服务。

![](https://confluence-connect.gliffy.net/embed/image/755ec27f-38e8-467e-ba1e-b2189848dc85.png)

值得一提的是，在每个具体的服务内部，我们又可以划分为接口层，应用层，领域层以及基础（数据）层等不同的层次。

## 接口服务

接口服务位于用户接口层，用于处理用户发送的 Restful 请求和解析用户输入的配置文件等，并将信息传递给应用层。

## 应用服务

应用服务位于应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装。应用层的服务包括应用服务和领域事件相关服务。

应用服务可对微服务内的领域服务以及微服务外的应用服务进行组合和编排，或者对基础层如文件、缓存等数据直接操作形成应用服务，对外提供粗粒度的服务。领域事件服务包括两类：领域事件的发布和订阅。通过事件总线和消息队列实现异步数据传输，实现微服务之间的解耦。

## 领域服务

领域服务位于领域层，为完成领域中跨实体或值对象的操作转换而封装的服务，领域服务以与实体和值对象相同的方式参与实施过程。领域服务对同一个实体的一个或多个方法进行组合和封装，或对多个不同实体的操作进行组合或编排，对外暴露成领域服务。领域服务封装了核心的业务逻辑。实体自身的行为在实体类内部实现，向上封装成领域服务暴露。

为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。
为实现微服务内聚合之间的解耦，原则上禁止跨聚合的领域服务调用和跨聚合的数据相互关联。

## 基础服务

基础服务位于基础层。为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。基础服务主要为仓储服务，通过依赖反转的方式为各层提供基础资源服务，领域服务和应用服务调用仓储服务接口，利用仓储实现持久化数据对象或直接访问基础资源。

# 微服务的设计原则

在微服务设计中，我们同样需要遵循中如[架构设计原则](https://ngte-se.gitbook.io/i/?q=架构设计原则)中高内聚低耦合、复用、单一职责等设计原则。

## 领域驱动

微服务设计首先应建立领域模型，确定逻辑和物理边界后，然后才进行微服务边界拆分，而不是一上来就定义数据库表结构，也不是界面需要什么，就去调整领域逻辑代码。领域模型和领域服务应具有高度通用性，通过接口层和应用层屏蔽外部变化对业务逻辑的影响，保证核心业务功能的稳定性。

## 边界与职能清晰

微服务完成开发后其功能和代码也不是一成不变的。随着需求或设计变化，微服务内的代码也会分分合合。逻辑边界清晰的微服务，可快速实现微服务代码的拆分和组合。DDD 思想中的逻辑边界和分层设计也是为微服务各种可能的分分合合做准备的。微服务内聚合与聚合之间的领域服务以及数据原则上禁止相互产生依赖。如有必要可通过上层的应用服务编排或者事件驱动机制实现聚合之间的解耦，以利于聚合之间的组合和拆分。

分层架构中各层职能定位清晰，且都只能与其下方的层发生依赖，也就是说只能从外层调用内层服务，内层服务通过封装、组合或编排对外逐层暴露，服务粒度由细到粗。应用层负责服务的编排和组合，领域层负责领域业务逻辑的实现，基础层为各层提供资源服务。

## 避免过度拆分

微服务的过度拆分必然会带来软件维护成本的上升，如：集成成本、运维成本以及监控和定位问题的成本。企业转型过程中很难短时间内提升这些能力，如果项目团队不具备这些能力，将很难 hold 住这些过细的微服务。而如果我们在微服务设计之初就已经定义好了微服务内的逻辑边界，项目初期我们可以尽可能少的拆分出过细的微服务，随着技术的积累和时间的推移，当我们具有这些能力后，由于微服务内有清晰的逻辑边界，这时就可以随时根据需要轻松的拆分或组合出新的微服务。

# 微服务的挑战

人月神话一书中提及，没有银弹，意思是只靠一把锤子是盖不起摩天大楼的，要根据业务场景选择设计思路和实现工具。微服务的优势可以如下所述：

- 每个服务足够内聚，足够小，代码容易理解、开发效率提高
- 服务之间可以独立部署，微服务架构让持续部署成为可能；
- 每个服务可以各自进行 x 扩展和 z 扩展，而且，每个服务可以根据自己的需要部署到合适的硬件服务器上；
- 容易扩大开发团队，可以针对每个服务（Service）组建开发团队；
- 提高容错性（Fault Isolation），一个服务的内存泄露并不会让整个系统瘫痪；
- 系统不会被长期限制在某个技术栈上；

而其缺点也很明显：

- 开发与运维复杂度的增加：开发人员要设计服务之间的通信机制，对于需要多个后端服务的业务场景，要在没有分布式事务的情况下实现代码非常困难；涉及多个服务直接的自动化测试也具备相当的挑战性；
- 真实系统往往难以明确划分边界：在生产环境中要管理多个不同的服务的实例，这意味着开发团队需要全局统筹；
- 状态管理与通信的复杂度；
- 分布式事务与版本管理；

## 接入网关

在巨石型架构下，客户端应用程序(Web 或者 App)通过向服务端发送 HTTP 请求；但是，在微服务架构下，原来的巨石型服务器被一组微服务替代，客户端为了完成一个业务逻辑，需要发起多个 HTTP 请求，从而造成系统的吞吐率下降，再加上无线网络的延迟高，会严重影响客户端的用户体验。

![](https://i.postimg.cc/595WYqWv/image.png)

为了解决这个问题，一般会在服务器集群前面再加一个角色：API gateway，由它负责与客户度对接，并将客户端的请求转化成对内部服务的一系列调用。这样做还有个好处是，服务升级不会影响到客户端，只需要修改 API gateway 即可。

## 服务发现与调用

单体应用的服务是可数且可人工运维的，而对于基于微服务架构的应用而言，其服务数非常多，数不胜数。因此，微服务框架要具有服务发现的能力。一般情况下，服务发现是通过向注册中心注册服务实例的运行时标识以及对其进行监听并反向通知其状态变化来实现的。

内部服务之间的通信方式有两种：基于 HTTP 协议的同步机制(REST、RPC)；基于消息队列的异步消息处理机制(AMQP-based message broker)。

- Dubbo 是阿里巴巴开源的分布式服务框架，属于同步调用，当一个系统的服务太多时，需要一个注册中心来处理服务发现问题，例如使用 ZooKeeper 这类配置服务器进行服务的地址管理：服务的发布者要向 ZooKeeper 发送请求，将自己的服务地址和函数名称等信息记录在案；服务的调用者要知道服务的相关信息，具体的机器地址在 ZooKeeper 查询得到。这种同步的调用机制足够直观简单，只是没有“订阅——推送”机制。

- AMQP-based 的代表系统是 Kafka、RabbitMQ 等。这类分布式消息处理系统将订阅者和消费者解耦合，消息的生产者不需要消费者一直在线；消息的生产者只需要把消息发送给消息代理，因此也不需要服务发现机制。

两种通信机制都有各自的优点和缺点，实际中的系统经常包含两种通信机制。例如，在分布式数据管理中，就需要同时用到同步 HTTP 机制和异步消息处理机制。

## 配置管理

相比于集中式架构的属性文件配置方式，微服务架构更加倾向于使用集中化的配置中心来存储配置数据。配置中心不一定在任何时候都是 100%高可用的，大部分时间，配置是从客户端的缓存中读取的，如果配置中心恰好在配置修改时不可用，就会带来很大的影响，导致配置修改无法及时生效。配置修改要想及时生效，配置中心必须有推送配置变更事件的能力。如果配置中心是高可用的，也要慎重考虑如何保证多个配置中心间的数据一致性。

## 服务可用性

负载均衡，与服务发现类似，大量的微服务应用实例无法通过静态修改负载均衡器的方式进行运维，因此需要反向代理或使用客户端负载均衡器配合服务发现动态调整负载均衡策略。

- 读写分离、分库分表：服务隔离与弹性扩缩容。这是集中式架构所不具备的能力，即能够在流量洪峰期通过增加应用实例的水平伸缩来增强服务的处理能力，并且能够在流量回归正常时简单地关闭应用实例，平滑地将多余的资源移出集群。

- 服务降级与容错：除了基础组件，在 DevOps 运维的角度看，我们还需要考虑分布式调用追踪、日志中心、系统自愈等方面。

- 分布式调用追踪。大量微服务应用的调用和交互，需要依靠一套完善的调用链追踪系统来实现，包括确定服务当前的运行状况，以及在出现状况时迅速定位相应的问题点。

- 日志中心。在微服务架构中，散落在应用节点上的日志不易排查，而且随着应用实例的销毁，日志也会丢失，因此需要将日志发送至日志中心统一进行存储和排查。

- 自愈能力。这是一个进阶功能，如果微服务应用可以通过健康检查感知各个服务实例的存活状态，并通过系统资源监控以及 SLA 分析获知应用当前的承载量，同时应用本身具有弹性扩缩容能力且微服务管控系统具有自动服务发现以及调整负载均衡的能力，那么便可以根据合理的调度策略配置通过调度系统来自动增加、关闭和重启应用实例，达到系统自愈的效果，使系统更加健壮。

## 分布式事务

随着互联网快速发展，微服务，SOA 等服务架构模式正在被大规模的使用，现在分布式系统一般由多个独立的子系统组成，多个子系统通过网络通信互相协作配合完成各个功能。而且这个过程中会涉及到事务的概念，即保证交易系统和支付系统的数据一致性，此处我们称这种跨系统的事务为分布式事务。

具体一点而言，分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果(全部提交或全部回滚)。
