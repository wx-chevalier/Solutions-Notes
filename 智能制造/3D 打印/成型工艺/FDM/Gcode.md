# Gcode

GCode是用来描述和控制加工路径的，有时候也叫“G语言”。没错，它是一种计算机语言，是给芯片（计算机、PCB）认的。G代码非常复杂，像大家常听到的直线插补、圆弧插补、样条插补都属于这个范围。

# RepRap

目前3D打印的G代码，基本上是Marlin风格：

![gcode 示例代码](https://s1.ax1x.com/2020/07/26/a9EToV.png)

“G1 X100  Y120”的意思是移动到（100，120）这个点，怎么做到的呢？喷头的移动是一个物理过程，本质上是电机的运动。这段代码如果要控制电机的运动，那么就要把它转化为电机的运动信号。那么基本架构应该是这样：

![pcb 示意图](https://s1.ax1x.com/2020/07/26/a9VMY8.png)

步进电机的运动是靠脉冲驱动的：一个脉冲转一个角度。CPU（PCB）通过控制发向电机驱动的脉冲的频率来控制电机的转速，转速通过螺杆将旋转运动转化为直线运动。3D打印机里运行在主板上的软件，就是固件，通常用C语言编写。FDM机器的固件起源于GRBL，它的程序和硬件都是开源的。大家可以搜索和下载它的源代码去研究，当然直接去研究Marlin系统也可以，基于GRBL开发的。

千万不要以为GRBL是唯一的，全世界用的G代码都一样的。但是你要知道，高端机床上千万的价格、低端桌面机床数百数千。他们的区别不只是丝杠、支撑架构这些硬件上的，更重要的还有固件。世界上有很多很多固件，有好有坏，每个厂家可能都有自己的固件，独有的技术往往就集成在这里面。

# Bresenham算法与DDA算法

假设有这样的装置：

![直线运动装置](https://s1.ax1x.com/2020/07/26/a9ZV9U.png)

有两个滑块分别位于X轴和Y轴上，移动两个滑块我们就能在XY平面上得到很多点。假如现在让你用一只手分别拨动这两个滑块，在XY平面上画一条直线L。方程是：Y = 5X + 10，请问你会怎么做？

做法很简单：X每拨1个单位长度，然后停下来，Y拨5个单位长度。所以最终的曲线是“折线”，是一条近似直线。当然这条近似直线可以做的非常光滑：比如X每次移动5微米，Y每次移动25um。宏观上肉眼察觉不到它是锯齿状的。所以我们对这一条直线的处理，有两种方法。

## 标记像素法（DDA）

![](https://s1.ax1x.com/2020/07/26/a9ZKBR.png)

## 近似法（Bresenham）

![](https://s1.ax1x.com/2020/07/26/a9Z1N6.png)

# Gcode的解析过程

上面看到的GRBL代码截图，哪些代码是C语言写的。写好了这个程序之后，就跟手机刷系统一样，通过数据线把它烧到PCB上，CPU就可以执行了。那么解析的过程呢？主要是这样：Gcode被以字符串的形式发到PCB上，PCB把里面的G、X、Y、E这些标记字母全部去掉（字符串处理函数），留下有意义的数值。

比如：G1 X10  Y60 F3600，G1 X30  Y50，这两行读进去以后，（10，60）、（30，50）这两个点将确定一条线，用上面的Bresenham算法，转化为X、Y电机运动的脉冲。CPU负责产生脉冲，经电路发给电机驱动器。F3600将被解析成脉冲频率，这中间将需要电机的步进角（一个脉冲转多少度）、同步带或者丝杠的螺距等等进行转换。那么类似加热怎么办呢？加热指令（一般M是指令）将被解析成一个开关信号（如5v电压信号）给加热棒的开关。怎么发形成脉冲呢？以Arduino为例，生成脉冲的C代码是这样：

```c
void pause(int num)
{
for (int count = 0; count < num; count++)
  {
for (int i = 5; i > 1; i--)
    {
      digitalWrite(8, HIGH);
      delay(30); #注意这里的30
      digitalWrite(8, LOW);
    }
  }
}
```

这个digitalWrite(8, HIGH)的作用，就是把6号管脚的电压设置成5v（HIGH），间隔30ms以后设置成低电压（LOW），不断循环重复这个过程，一会儿高、一会儿低，这就是脉冲，就能发给步进电机了，让它转动。调整高低脉冲之间的间隔，例如把30ms设置成100ms，频率就低了，相应的电机转速慢了，喷头也就移动的慢了。

![pcb 板](https://s1.ax1x.com/2020/07/26/a9eURU.png)

# Gcode 生成

在FDM中，我们用Cura等软件切片填充而来。填充软件上层还有个设计软件，比如Solidworks、UG、犀牛等等。